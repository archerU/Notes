# 基于 GraphQL - Cocktail（idc 4.0）导购场景下的 Data Graph（一）

Cocktail 是一个 BFF(Backend For Frontend) ，它允许你把已定义好的 HSF，HTTP 等服务转变成 Graphql 接口，并将各个微服务，按照它们的数据关联，整合成一个基于 GraphQL Schema 的数据关系网络。

## 封面

![屏幕快照 2019-08-23 下午2.50.22](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-23%20%E4%B8%8B%E5%8D%882.50.22.png)


## 前言

随着多终端、多平台、多业务形态、多技术选型等各方面的发展，前后端的数据交互，日益复杂。

同一份数据，可能以多种不同的形态和结构，在多种场景下被消费。

在理想情况下，这些复杂性可以全部由后端承担。前端只管从后端接口里，拿到已然整合完善的数据。

然而，因为微服务架构。作为前端，我们感受到的是，后端提供的接口，越发不够前端友好。我们必须自行组合多个后端接口，才能获取到完整的数据结构。

在这种背景下，我们搭建专门服务于前端页面呈现的平台 Cocktail。

## 前端的困境

面向前端页面的数据聚合层，其接口很容易在迭代过程中，变得愈加复杂；最终发展成一个超级接口。

它有很多调用方，各种不同的调用场景，甚至多个不同版本的接口并存，同时提供数据服务。所有这些复杂性，都会反映到接口参数上。

接口调用的场景越多，它对接口参数结构的表达能力，要求越高。

### 一、层级

前端的一个痛点是，层级。对于前端来说，超过三个的层级判断就已经非常复杂，而服务端因为平台开发不同，网关等因素，往往返回前端真正有用的数据在非常深的层级。这对前端来说是非常大讨厌的。我们期望拿到不超三个层级且扁平的数据结构。

### 二、命名

前端的另一个痛点是，命名。前端经常吐槽后端的字段名过于冗长，或者不知所云，或者拼写错误，或者不符合前端表述习惯，或者前端已有开发完成的组件但是字段却与服务端的字段不匹配等。反正我们期望有机会进行字段名调整。

### 三、适配

前端导购场景很大一部分是基于组件搭建的。这些组件多多少少都可以被复用。但却会因为服务端的数据结构不同导致可被复用的组件重新再开发一遍。因此，前端希望能有中间层转换服务端结构对应前端视图结构。

### 四、请求

前端常常会因为需要接口组装出现合并请求（并发或者流式）的情况，前端的合并请求往往影响页面渲染性能和代码复杂度。前端希望的是一个操作便能返回需要的数据。

### 五、文档

前端还需要去查看接口文档，而文档的编写、查找、更新、版本管理等都成为一个耗费时间且会令人疑惑的问题。

### 六、数据集

服务端返回的数据集往往冗余，极度影响前端去视图上绑定数据。前端希望视图上用到什么数据就返回什么数据。

## 基于 GraphQL 的查询

我们从结果出发，想象理想的接口查询。我们一般的查询结果是 JSON 数据格式的。而 JSON 是一个 key-value pair 风格的数据表示，因此可以从结果倒推出跟查询结果相近的查询语句。

![屏幕快照 2019-08-26 下午5.28.03](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8B%E5%8D%885.28.03.png)


上图是一个查询结果。很显然，它的查询语句不可能包含 value 部分。我们删去 value 后，它变成下面这样。

![屏幕快照 2019-08-26 下午5.32.26](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8B%E5%8D%885.32.26.png)


查询语句跟查询结果拥有相同的 key 及其层次结构关系。这是我们想要的。

我们将冗余的双引号，逗号等部分删掉。

![屏幕快照 2019-08-26 下午5.36.10](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8B%E5%8D%885.36.10.png)

我们得到了一个精简的写法，它已经是一段合法的 GraphQL 查询语句了。

当然，如果我们需要获取具体的商品信息，那么就需要传入参数。

![屏幕快照 2019-08-26 下午5.38.16](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8B%E5%8D%885.38.16.png)


上图是一个自然而然的做法。用括号表示函数调用，里面可以添加参数。

前面演示的 GraphQL 参数写法，参数值用的是字面量 offerId: 123。这不是一个特别安全的做法，开发者会在代码里，用拼接字符串的方式将字面量值注入到查询语句，也就给了恶意攻击者注入代码的机会。

我们需要设计一个参数变量语法，明确参数位置和数量。

![屏幕快照 2019-08-26 下午5.39.45](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8B%E5%8D%885.39.45.png)

我们可以选用 $xxx 这种常见的标记方法，它被很多语言采用来表示变量。沿用这种风格，可以大大减少开发者的学习成本。

现在有字段、层级和筛选条件了，但是符合这种结构的数据太多了，我们也不知道应该从哪里去查询。我们还需要设计将商品信息挂载到一个具体的服务上。

![屏幕快照 2019-08-26 下午5.48.09](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8B%E5%8D%885.48.09.png)

GraphQL Schema 描述了数据的类型与结构，但它只是形状（Shape），它不包含真正的数据。前端需要传递 query 查询语句，触发调用。因此在最外层我们还需要加上Query。最终我们的查询语句是这样子的。![屏幕快照 2019-08-27 下午4.16.36](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-27%20%E4%B8%8B%E5%8D%884.16.36.png)


如上所示，我们发起了查询，传递了参数。GraphQL 会解析我们的查询语句，然后跟 Schema 进行数据形状的验证，确保我们查询的结构是存在的，参数是足够的，类型是一致的。任何环节出现问题，都将返回错误信息。

数据形状验证通过后，GraphQL 将会根据 query 语句包含的字段结构，一一触发并获取查询结果。也就是说，如果前端没有查询某个字段，就不会产生对数据的获取行为。这样 GraphQL 服务能实现按需获取数据，精确传递数据。

### 合并查询

在原来使用 RESTful 形式时，服务端存在大量转发数据请求，聚合数据结果的工作。而使用 Graphql 形式，前端可以一次请求所需数据，无需服务端包接口。


![屏幕快照 2019-08-27 下午4.19.08](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-27%20%E4%B8%8B%E5%8D%884.19.08.png)

### 关联查询

当我们的服务是按照领域模型来划分时，商家、商品属于不同的服务。如果想实现一个商带品的接口，通过 Graphql 形式我们可以很容易将它们整合到一起。

![屏幕快照 2019-08-27 下午4.21.50](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-27%20%E4%B8%8B%E5%8D%884.21.50.png)


### 天生文档

GraphQL 提供的开发工具 GraphiQL，可以检查 GraphQL 的语法，发送 GraphQL 的请求，还提供文档查询功能。点击右上角的 `< Docs` 可以看到。


![屏幕快照 2019-08-27 下午2.02.34](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-27%20%E4%B8%8B%E5%8D%882.02.34.png)

上面的 ROOT TYPES 表示最顶层支持的类型，只有一个 Query。点击 Query，可以看到该类型包含的字段。仔细看，会发现这些字段的值又都是类型。

![屏幕快照 2019-08-27 下午2.05.03](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-27%20%E4%B8%8B%E5%8D%882.05.03.png)

找到 `OfferModel`，我们是可以查找这个字段的，写出如下的查询语言，准备执行时，会看到 resource_offer_query_ability 下方有条红线，鼠标放上去，提示需要传入的参数。

![屏幕快照 2019-08-27 下午2.11.55](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-27%20%E4%B8%8B%E5%8D%882.11.55.png)

我们加入参数，执行就能获取指定的结果了。相比于读服务端提供的文档，调试参数和结果的方式，这种无需编写文档，随时调试，所见即所得的方式更方便。

## Cocktail 核心思想

Cocktail 的核心思路是，将多个 services 整合成一个中心化 data graph。

![屏幕快照 2019-08-27 下午3.01.47](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-27%20%E4%B8%8B%E5%8D%883.01.47.png)



每个 service 的数据结构契约，都放入了一个大而全的 GraphQL Schema 里；如果不做任何模块化和解耦，开发体验将会非常糟糕。每个团队成员，都去修改同一份 Schema 文件。

这明显是不合理的。GraphQL-BFF 的开发模式，应该跟 service 的领域模型，有一一对应的关系。然后通过某种形式，多个 services 自然整合到一起。

### 模型映射

配置视图模型与服务端领域模型进行映射的流程。

![屏幕快照 2019-08-23 下午3.32.47](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-23%20%E4%B8%8B%E5%8D%883.32.47.png)


###  优雅的 IDE

![屏幕快照 2019-08-23 下午3.48.37](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-23%20%E4%B8%8B%E5%8D%883.48.37.png)



## 最佳实践

### 职责分工

1、数据提供方接入 数据模型
2、数据消费方编写 视图模型
这种组合是比较推荐的最佳实践，但不意味着数据消费方就不应该去涉及接入数据的工作。

### 去中心化玩法 

我们推荐使用的方式：客户端sdk + cocktail平台配置 + 服务端sdk
这套玩儿法最符合我们完全去中心化的设计初衷。

![屏幕快照 2019-08-26 上午11.58.12](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8A%E5%8D%8811.58.12.png)

cocktail 平台地址：http://cocktail.alibaba.net

客户端调用方式：https://yuque.antfin-inc.com/cocktail/kn47vu/gw7m2n

服务端调用方式：https://yuque.antfin-inc.com/cocktail/kn47vu/mghlg2

### 平台化玩法

虽然我们提倡去中心化的方式，但是也有一部分业务是无法接入二方包的情况。我们有提供集中化流量的玩法。

![屏幕快照 2019-08-26 上午11.55.05](media/15627686614573/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-26%20%E4%B8%8A%E5%8D%8811.55.05.png)

## 总结

在 GraphQL 这个中间层里，我们将各个微服务，按照它们的数据关联，整合成一个基于 GraphQL Schema 的数据关系网络。前端可以通过 GraphQL 查询语句，同时发起对多个微服务的数据的获取、筛选、裁剪等行为。

如此，既避免了前端需要一对多的问题，也解决了 API Gateway GraphQL 需要请求 RESTful 全量数据接口的内部冗余问题。让服务到服务之间的数据调用，也可以做到更精确。

GraphQL 服务是一个对数据消费方友好的模式。而数据消费方，既可以是前端，也可以是其它服务。

当数据消费方是其它服务时，通过 GraphQL 查询语句，彼此之间可以更精确获取数据，避免冗余的数据传输和接口调用。

----- 

Cocktail 平台基于 GraphQL 将服务和前端所需的视图模型进行关联，期间可以对服务数据进行层级减少，重命名等处理。

我们将各个微服务，按照它们的数据关联，自然而然整合成一个基于 GraphQL Schema 的数据关系网络。前端可以通过 GraphQL 查询语句，同时发起对多个微服务的数据的获取、筛选、裁剪等行为。

GraphQL 服务是一个对数据消费方友好的模式。通过 GraphQL 查询语句，可以更精确获取数据，避免冗余的数据传输和接口调用。

## 参考

https://weibo.com/ttarticle/p/show?id=2309404398215846821987

https://aotu.io/notes/2017/12/15/graphql-use/index.html


```
query($id: Long, $topicId: Long, $brandId: Long){
  search_member_query_service(topicId: $topicId, brandId: $brandId) {
    memberModal {
      memberId
      bId: brandId
      companyName
      search_offer_service(offerId: $id) {
        offer {
          offerId
          title
          marketField
          collectNum
          originPrice
          isCys
          tagField
          agentFixPrice
          price
          shortText
          isBestOffer
          image
        }
      }
    }
  }
}

```